Some Recommendations from the bootcamp for how to proceed with this project:


# Recommendations

Here's a list of recommended action items to do during and after the development, to help you more effectively build the project and learn from the project.

During Development:

    You can either create your own Rust project and copy over the code in each step or clone this repo and finish the steps directly in this repo.

    Check the project description/requirements to make sure you are building what is asked of you.
    
    Refactor as you implement. Keep your code clean and compartmentalized. Doing so makes debugging exponentially easier, as your implementation grows.
    
    Make sure your code compiles and all tests are passing (if applicable) before moving on to the next step.

    If you get stuck, ask for help in the Discord server or look at the next step for the solution to the current step.


After Development:

    Run through the provided manual test cases (included in the Stage 3 README), and fix any bugs! You are almost done, so finish the project strong!

    Post your completed project on GitHub

    After completing the project feel free to modify the program by changing the architecture, adding features, etc. This will help you make the project your own and better internalize the lessons you've learned.





# FAQs

Will there a template to build the project on top of?

Yes. Each step has a partially built Rust project for you to finish. Stages and steps build on top of each other until you have a completed project.


Should my implementation look exactly like the solution?

Your code may differ from the solution, as long as your code compiles, tests are passing, and the program works as intended you are in good shape. Also after completing the project feel free to modify the program by changing the architecture, adding features, etc.


NOTE: If you don't know how to implement a TODO item, look at the corresponding test to see what is expected.




# Stages Overview

The project is split into multiple stages. Please keep in mind, some implementation choices are made to minimize the scope of the project, so we can focus on the learning and implementing Rust related concepts. Here's an overview of the stages:

### Stage 1

Database and Models

In this state we will design our models, persist them in a JSON file, and build CRUD operations for Epics and Stories.

### Stage 2

UI (pages and prompts)

In this state we will implement the user interface for our application.

### Stage 3

Navigation and Program Loop

In this stage we will hook up our persistent storage component to the UI. We will also implement navigation and the program loop.







Stage 1 overview:

Database and Models

"In backend development projects, the database design is often the very first task to complete.  The database design determines what and how information is imported and stores for repeates usages"

"While designing the databse (what technologies to use, how to model it, etc), we can very quickly assess if the project is feasible and if we can meet the requirements"

"In this project, we will persist Epic and Story records in a JSON file to keep things as simple as possible.

The JSON model contains the following components:

    last_item_id

        A global integer ID counter for both Epics and Stories.  Each newly created Epic/Story will increment the counter.

    epics

        A mapping between Epic IDs and the actual Epics.  An Epic will consist of a list of Stories in the form of Story IDs.

    stories

        A mapping between Story IDs and actual Stories

    epic and story each have:

        name

        description

        status

    status can be:

        Open

        InProgress

        Resolved

        Closed"




The file will be stored in data/db.json

Example of what the JSON file will look like:

{
    "last_item_id": 3,
    "epics": {
        "1": {
            "name": "Epic - Project 1",
            "description": "This is Project 1 for the Bootcamp",
            "status": "InProgress",
            "stories": [
                2,
                3
            ]
        }
    },
    "stories": {
        "2": {
            "name": "Story - Project 1 Solution",
            "description": "Please provide full implement for Project 1",
            "status": "Closed"
        },
        "3": {
            "name": "Story - Project 1 README",
            "description": "Please create README file for Project 1",
            "status": "InProgress"
        }
    }
}


Step 1:

Modeling the JSON representation in Rust

Take the JSON representation and translate it into Rust Structs and Enums.  Do this by completing the TODO items in models.rs

-- this is done



Step 2:

Reading and writing to the JSON file

a new file called db.rs will be added.  This is where the logic will be stored which handles reading and writing the JSON file.

This file contains two items: Database and JSONFileDatabase.

Database is a trait with two methods, read_db and write_db

For simplicity, we will read/write the entire state of the database

JSONFileDatabase is a Struct that implements the Database trait.

A few dependencies are also being added:

    anyhow, for error handling

    serde and serde_json for serializing/deserializing JSON

    tempfile, added as a dev dependency to help with testing

Complete this step by finshing the TODO items in db.rs and models.rs


-- currently done adding PartialEq and Debug derive statements,

-- next the todo!() macros need to be cleared out in db.rs and then this step will be complete

-- refactoring might be good, it's possible to reduce repeated code in the db.rs tests module


Step 3:

Add CRUD operations for Epics/Stories

Another Struct called JiraDatabase has been added to db.rs.  It will contain methods for CRUD operations for Epics and Stories.

Complete this step by finishing the TODO items in db.rs

Note 1: use the anyhow!() macro for error handling 

Note 2: Take a look at the test_utils module.  Because JiraDatabase stores a trait object which can be any type that implement Database, we can create a mock database for testing (MockDB).  Also note that MockDB uses the RefCell smart pointer.  This is because write_db() takes an immutable reference to self and we need some way to work around this constraint